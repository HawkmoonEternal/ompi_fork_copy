.\"t
.\" Automatically generated by Pandoc 2.0.6
.\"
.TH "MPI_Graph_create" "3" "" "2022\-07\-05" "Open MPI"
.hy
.SH Name
.PP
\f[C]MPI_Graph_create\f[] \- Makes a new communicator to which topology
information has been attached.
.SH Syntax
.SS C Syntax
.IP
.nf
\f[C]
#include\ <mpi.h>

int\ MPI_Graph_create(MPI_Comm\ comm_old,\ int\ nnodes,\ const\ int\ index[],
\ \ \ \ const\ int\ edges[],\ int\ reorder,\ MPI_Comm\ *comm_graph)
\f[]
.fi
.SS Fortran Syntax
.IP
.nf
\f[C]
USE\ MPI
!\ or\ the\ older\ form:\ INCLUDE\ \[aq]mpif.h\[aq]

MPI_GRAPH_CREATE(COMM_OLD,\ NNODES,\ INDEX,\ EDGES,\ REORDER,
\ \ \ \ \ \ \ \ COMM_GRAPH,\ IERROR)
\ \ \ \ INTEGER\ COMM_OLD,\ NNODES,\ INDEX(*),\ EDGES(*)
\ \ \ \ INTEGER\ COMM_GRAPH,\ IERROR
\ \ \ \ LOGICAL\ \ \ REORDER
\f[]
.fi
.SS Fortran 2008 Syntax
.IP
.nf
\f[C]
USE\ mpi_f08

MPI_Graph_create(comm_old,\ nnodes,\ index,\ edges,\ reorder,\ comm_graph,
\ \ \ \ \ \ \ \ ierror)
\ \ \ \ TYPE(MPI_Comm),\ INTENT(IN)\ ::\ comm_old
\ \ \ \ INTEGER,\ INTENT(IN)\ ::\ nnodes,\ index(nnodes),\ edges(*)
\ \ \ \ LOGICAL,\ INTENT(IN)\ ::\ reorder
\ \ \ \ TYPE(MPI_Comm),\ INTENT(OUT)\ ::\ comm_graph
\ \ \ \ INTEGER,\ OPTIONAL,\ INTENT(OUT)\ ::\ ierror
\f[]
.fi
.SH Input Parameters
.IP \[bu] 2
\f[C]comm_old\f[] : Input communicator without topology (handle).
.IP \[bu] 2
\f[C]nnodes\f[] : Number of nodes in graph (integer).
.IP \[bu] 2
\f[C]index\f[] : Array of integers describing node degrees (see below).
.IP \[bu] 2
\f[C]edges\f[] : Array of integers describing graph edges (see below).
.IP \[bu] 2
\f[C]reorder\f[] : Ranking may be reordered (true) or not (false)
(logical).
.SH Output Parameters
.IP \[bu] 2
\f[C]comm_graph\f[] : Communicator with graph topology added (handle).
.IP \[bu] 2
\f[C]IERROR\f[] : Fortran only: Error status (integer).
.SH Description
.PP
\f[C]MPI_Graph_create\f[] returns a handle to a new communicator to
which the graph topology information is attached.
If \f[C]reorder\f[] = false then the rank of each process in the new
group is identical to its rank in the old group.
Otherwise, the function may \f[C]reorder\f[] the processes.
If the size, \f[C]nnodes\f[], of the graph is smaller than the size of
the group of \f[C]comm_old\f[], then some processes are returned
\f[C]MPI_COMM_NULL\f[], in analogy to \f[C]MPI_Cart_create\f[] and
\f[C]MPI_Comm_split\f[].
The call is erroneous if it specifies a graph that is larger than the
group size of the input communicator.
.PP
The three parameters \f[C]nnodes\f[], \f[C]index\f[], and \f[C]edges\f[]
define the graph structure.
\f[C]nnodes\f[] is the number of nodes of the graph.
The nodes are numbered from 0 to \f[C]nnodes\f[]\-1.
The ith entry of array \f[C]index\f[] stores the total number of
neighbors of the first i graph nodes.
The lists of neighbors of nodes 0, 1, \&..., \f[C]nnodes\f[]\-1 are
stored in consecutive locations in array \f[C]edges\f[].
The array \f[C]edges\f[] is a flattened representation of the edge
lists.
The total number of entries in \f[C]index\f[] is \f[C]nnodes\f[] and the
total number of entries in \f[C]edges\f[] is equal to the number of
graph \f[C]edges\f[].
.PP
The definitions of the arguments \f[C]nnodes\f[], \f[C]index\f[], and
\f[C]edges\f[] are illustrated with the following simple example.
.PP
Example: Assume there are four processes 0, 1, 2, 3 with the following
adjacency matrix:
.PP
.TS
tab(@);
l l.
T{
Process
T}@T{
Neighbors
T}
_
T{
0
T}@T{
1, 3
T}
T{
1
T}@T{
0
T}
T{
2
T}@T{
3
T}
T{
3
T}@T{
0, 2
T}
.TE
.PP
Then, the input arguments are: * \f[C]nodes\f[] = 4 * \f[C]index\f[] =
2, 3, 4, 6 * \f[C]edges\f[] = 1, 3, 0, 3, 0, 2
.PP
Thus, in C, \f[C]index[0]\f[] is the degree of \f[C]node\f[] zero, and
\f[C]index[i]\f[] \- \f[C]index[i\-1]\f[] is the degree of \f[C]node\f[]
i, i=1, .
\&.
\&.
, nnodes\-1; the list of neighbors of node zero is stored in
\f[C]edges[j]\f[], for 0 <= j <= \f[C]index[0]\ \-\ 1\f[] and the list
of neighbors of \f[C]node\f[] i, i > 0 , is stored in \f[C]edges[j]\f[],
\f[C]index[i\-1]\f[] <= j <= \f[C]index[i]\ \-\ 1\f[].
.PP
In Fortran, \f[C]index(1)\f[] is the degree of \f[C]node\f[] zero, and
\f[C]index(i+1)\f[] \- \f[C]index(i)\f[] is the degree of \f[C]node\f[]
i, i=1, .
\&.
\&.
, nnodes\-1; the list of neighbors of \f[C]node\f[] zero is stored in
\f[C]edges(j)\f[], for 1 <= j <= \f[C]index(1)\f[] and the list of
neighbors of \f[C]node\f[] i, i > 0, is stored in \f[C]edges(j)\f[],
\f[C]index(i)\ +\ 1\f[] <= j <= \f[C]index(i\ +\ 1)\f[].
.SH Errors
.PP
Almost all MPI routines return an error value; C routines as the value
of the function and Fortran routines in the last argument.
.PP
Before the error value is returned, the current MPI error handler is
called.
By default, this error handler aborts the MPI job, except for I/O
function errors.
The error handler may be changed with \f[C]MPI_Comm_set_errhandler\f[];
the predefined error handler \f[C]MPI_ERRORS_RETURN\f[] may be used to
cause error values to be returned.
Note that MPI does not guarantee that an MPI program can continue past
an error.
.SH See Also
.PP
\f[C]MPI_Graph_get\f[](3) \f[C]MPI_Graphdims_get\f[](3)
